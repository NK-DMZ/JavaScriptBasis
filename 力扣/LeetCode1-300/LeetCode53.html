<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>53. 最大子序和</title>
</head>

<body>
    <div>      
        <h1><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h1>
        给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
        <hr>
        示例 1：<br>
        输入：nums = [-2,1,-3,4,-1,2,1,-5,4] <br>
        输出：6 <br>
        解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
        <hr>
        示例 2：<br>
        输入：nums = [1] <br>
        输出：1
        <hr>
        <div>
            示例 3：<br>
            输入：nums = [0] <br>
            输出：0
            <hr>
            示例 4： <br>
            输入：nums = [-1] <br>
            输出：-1
            <hr>
            示例 5：<br>
            输入：nums = [-100000] <br>
            输出：-100000
            <hr>
        </div>
        提示：
        <!-- 1 <= nums.length <= 105
        -104 <= nums[i] <= 104 -->
        <div>
            <h3>思路</h3>
            <p>1.定义变量存储当前累加数组的和</p>
            <p>2.比较当前数组的和和上一次的结果，如果大就舍弃之前的数组</p>
        </div>

    </div>
    <script>
        // 动态规划转移方程：
        // f(i) = max ( f(i - 1) + nums[i] , nums[i] )

        // 执行用时：188 ms, 在所有 JavaScript 提交中击败了5.01%的用户
        // 内存消耗：53.2 MB, 在所有 JavaScript 提交中击败了5.01%的用户
        var maxSubArray = function (nums) {
            console.log(nums);
            // 存储当前数组元素与之前数组和的结果
            let currentAddnum;
            // 存储上一次数组元素之和
            let lastAddnum = 0;
            let lastarr = [];
            for (let i = 0; i < nums.length; i++) {
                console.log(`lastAddnum是${lastAddnum}`);
                currentAddnum = nums[i] + lastAddnum;
                console.log(`currentAddnum是${currentAddnum}`);
                if (currentAddnum > nums[i]) {
                    lastAddnum = currentAddnum;
                    lastarr.push(lastAddnum);
                } else {
                    lastAddnum = nums[i];
                    lastarr.push(lastAddnum);
                }
                console.log(`修改后的lastAddnum是${lastAddnum}`);
                console.log("------");
            }
            lastarr.sort((a, b) => a - b)
            let res = lastarr[lastarr.length - 1]
            console.log(res);
        };

        // 执行用时：80 ms, 在所有 JavaScript 提交中击败了65.03%的用户
        // 内存消耗：46.2 MB, 在所有 JavaScript 提交中击败了41.97%的用户
        var maxSubArray = function (nums) {
            console.log(nums);
            // 存储当前数组元素与之前数组和的结果
            let currentAddnum;
            // 存储上一次数组元素之和
            let lastAddnum = 0;
            let res = nums[0];
            for (let i = 0; i < nums.length; i++) {
                console.log(`lastAddnum是${lastAddnum}`);
                currentAddnum = nums[i] + lastAddnum;
                console.log(`currentAddnum是${currentAddnum}`);
                if (currentAddnum > nums[i]) {
                    lastAddnum = currentAddnum;
                    res = Math.max(res, lastAddnum);
                } else {
                    lastAddnum = nums[i];
                    res = Math.max(res, lastAddnum);
                }
                console.log(`修改后的lastAddnum是${lastAddnum}`);
                console.log("------");
            }
            console.log(res);
        };
        maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4])
        maxSubArray([-2, 1])
    </script>
</body>

</html>
[-2, 1, -3, 4, -1, 2, 1, -5, 4]
-2 -1 -4 0 -1 1 3 -2 2